Хотим понять как работает компилятор, как процессор выполняет исполняемый файл, как работает ОС, как программы делят между собой ресурсы и как все это работает. Для этого будем писать программы на ассемблере, потом на C (будем смотреть как язык С транслируется в ассемблер, а потом и в машинный код), изучать устройство ОС, процессора и т.д.

Курс разделен на две части: "Архитектура Компьютера" и "Операционные системы и Промышленная Разработка"

## Компьютеры
Аналоговое устройство - бесконечное количество состояний

Цифровое устройство - конечное число состояний

### Архитектура Фон Неймана

![](../common/Pasted%20image%2020250306122716.png)

Попытка унифицировать инструкции для компьютера и данные, над которыми он проводит вычисления

У нас есть *обрабатывающее устройство (процессор) - Central Processing Unt*, в нем находится *арифметико-логическое устройство - Arithmetic/Logic Unit*, которое выполняет вычисления. Имеется *контрольное устройство - Control Unit*, которое говорит арифметико-логическому устройству, что ему делать

Так же у нас есть *память - Memory*, которая состоит из последовательности ячеек одинакового размера. У каждой ячейки свой номер - *адрес*

Так же есть *устройства ввода/вывода - Input/Output Device*, но они нас сейчас не интересуют. Будем говорить только про центральную часть

Фон-Неймановский компьютер:
- электронный, цифровой
- адресуемая память - можем в любой момент спросить память, что записано в определенной ячейки или записать туда какую-то информацию
- хранимая программа (Stored Programm) в виде набора инструкций - хранится в памяти в виде чисел, которые обозначают, какие действия хотим выполнять на каком шаге вычислений
- инструкции и данные хранятся в одной и той же памяти, инструкции можно обрабатывать как данные - в целом не можем отличить, где данные, а где инструкции - везде хранятся числа, вопрос в том как их проинтерпретировать
- инструкции исполняются по одной, в определенной последовательности. Есть *IP - Instruction Pointer* - ячейка памяти внутри *Control Unit*, где хранится адрес текущей инструкции

На каждом шаге своей работы такая машина делает:
1) `fetch` - из памяти, по адресу, который в Instruction Pointer, приносим следующую инструкцию
2) `decode`  - определяем, как она будет исполняться. Составляем более подробные инструкции для АЛУ (Арифметико-Логического устройства)
3) `execute` - исполняем эту инструкцию. Производим вычисления которые нужны, после это обновляем Instruction Pointer (типичный способ инкрементировать его)

**Нам нужны условные вычисления и циклы. Только арифметических инструкций недостаточно, надо управлять потоком исполнения**

Все управление потока управления происходит с помощью обновления Instuction Pointer

Например, запись бесконечного цикла, который постоянно инкрементирует переменную

![](../common/Pasted%20image%2020250306124138.png)

В ячейке 248 инструкция, которая производит *безусловный переход* - скажет контрольному устройству не обновлять Instruction Pointer на 249, а поставить на 247. Получился цикл

Все управление потоком управления, ветвления, циклы и т.п. обеспечивается в архитектуре Фон Неймана обновлением Instruction Pointer'а

Ячейки памяти внутри процессора будем называть *регистрами*

Будем рассматривать архитектуру *x86*

*ISA (Instruction Set Architecture)* - набор инструкций конкретного компьютера, их семантика и способ кодирования в памяти. В любом компьютере конечное число инструкций. Примеры ISA: x86, ARM, MIPS, RISC-V

Одна и так же ISA может быть по разному реализована по-разному на уровне *микроархитектуры* - от этого может зависеть скорость или эффективность исполнения программ

**Проблема:** в памяти и инструкции, и данные. Надо взять инструкцию из памяти, операнды, а потом положить результат операции в память

Из-за этого шина в памяти становится бутылочным горлышком (узким местом) - надо все время пропихивать много информации, идут и инструкции, и данные

В *Гарвардской архитектуре* была принята попытка разделить инструкции и данные, хранить их отдельно

Современные компьютеры не реализуют в чистом виде ни одну их этих архитектур, а берут части от каждой из них

## Целые числа
Двоичное представление числа - представляем число в виде суммы степеней двойки
$$42 = 32 + 8 + 2 = 2^5 + 2^3 + 2^1 = 101010_2$$
Компьютеры у нас двоичные (самые надежные и дешевые элементы для компьютеров двоичные)

Все содержимое памяти компьютера представлено в виде комбинации битов - элементы, у которых может быть одно из двух состояний. Обычно работаем не с отдельными битами, а с их группами. *Байт* - минимальная адресуемая единица памяти. 1 байт = 8 бит

Нумеруем биты, в соответствии с тем, какую степень двойки он представляет в числе - справа нулевой бит, левее первый и т.д.

Ячейки памяти могу быть разного размера
```
8 бит
00000000 = 0
11111111 = 255

16 бит
0000000000000000 = 0
1111111111111111 = 65535 (2^16 - 1)
```

Обычно пользуемся 16-ричными цифрами. В каждой 16-ричной цифре 4 двоичных разряда (16 = 2^4)

Переполнение 16-битной ячейки памяти
```
  0xffff = 65535
+ 0x0001
= 0x0000
```
Получается все арифметика по модулю 2^N, N в зависимости от используемых ячеек памяти

### Знаковые числа
Надо часть комбинаций битов, которые возможны в данной ячейке памяти отдать под отрицательные числа

Для этого используется *два-дополнительный код - two's complement representation*

![](../common/Pasted%20image%2020250306130758.png)

Старший бит является знаковым битом. Арифметика как была по модулю 2^N, так и осталась по модулю 2^N 

Процессор одинаково производит сложение и вычитание со знаковыми и беззнаковыми числами

![](../common/Pasted%20image%2020250306131204.png)

"Переполнение" беззнаковых числе происходит вполне логично
```
  0xffff = 65536
+ 0x0001
= 0x0000 = 0
```

У знаковых чисел происходит *знаковое переполнение*

В системе инструкций процессора не может быть UB - процессор спаян определенным образом и при любой комбинации входных данных и инструкций он ведет себя каким-то образом. Если бы процессор запрещал нам производить какие-то операции, то у нас были бы проблемы

Процессор ведет себя определенным образом. Если залезу в мусор и попытаюсь выполнить историю, то процессор нам сообщит, что такой инструкции у нас нет (кинет исключение и ОС нам как-то сообщит об этом)

*CPU - Central Processing Unit или же просто Процессор*

## Язык ассемблера
Многие из нас пользуются архитектурой x86. Все компьютеры, на которых работает Windows - это компьютеры архитектуры x86 (история от 16-битных процессоров). Много недостатков из-за обратной совместимости со старыми версиями  

### Машинный код и язык ассемблера
У всех регистров внутри процессора обычно одинаковый размер. Это максимальный размер чисел, с которыми удобно работать. Адреса в памяти обычно имеют размер, который помещается в регистр 

Читать инструкции процессора в виде чисел очень неудобно, писать тем более. Например, реализация алгоритма Евклида для 32-битных чисел на x86
```
39 c8 74 07 77 01 91 29 c8 eb f5
```

*Регистр - ячейка памяти внутри процессора. Их там несколько*

Процессор в каждый момент через Instruction Pointer смотрит на какой-то байт, понимает сколько байт занимает инструкция, которая с него начинается (бывают однобайтовые, двухбайтовые инструкции), выполняет ее, движется дальше

***Если в инструкции сказано прибавить к Instruction Pointer какое-то число, то оно прибавиться после выполнения этой инструкции, когда Instruction Pointer уже сдвинется на один вперед. То есть Instruction Pointer сдвинется вперед и потом к нему прибавится заданное число***

Когда начинаем выполнять инструкцию Instruction Pointer уже сдвинут на начало следующей

Процессор смотрит на первый байт инструкции и понимает, сколько байт она занимает. Процессор вынужден декодировать каждую следующую инструкцию, начиная с ее первого байта

Чтобы не писать машинный код руками сделали конвертер, который принимает на вход текстовые представления инструкций и пишет за нас машинный код

Каждая инструкция записывается как мнемоника (название) этой инструкции и операнды
```asm
cmp eax, ecx // сравнить регистры 0 и 1
je 0x4321b // условный переход, если числа равны - jump if equal
ja 0x43217 // условный переход, если первое число больше - jump if above
xchg eax, ecx // поменять местами регистры - exchange
```

В мире x86 есть 2 синтаксиса, которые используются больше всего - Intel и AT&T (применяется больше в GNU). Мы будем пользовать синтаксисом Intel

### Регистры
Внутри процессора есть некоторое количество ячеек памяти, к которым процессору быстрее обращаться, не надо ходить за ними в память

![](../common/Pasted%20image%2020250306160744.png)

В архитектуре Фон Неймана был Instruction Pointer в CPU - одна ячейка памяти, а все остальное мы могли держать в обобщенной линейно адресуемой оперативной памяти

В реальном мире у нас есть процессор, в нем есть некоторое количество ячеек памяти (Registers), в том числе и Instruction Pointer. Память очень большая и медленная, поэтому между процессором и памятью есть еще и кэш (Cache), но процессор этого обычно не замечает, и мы как программисты этого обычно тоже не замечаем. Для нас важно разделение на регистры (ячейки памяти внутри процессора) и данные в адресуемой памяти

Instruction Pointer имеет мнемоническое название `rip` - register of instruction pointer. Все регистры начинаются с буквы `r` и какие-то еще дальше буквы

`rip` - регистр специального назначения, туда нельзя положить данные на хранение. Процессору нужен этот регистр, чтобы знать, где он сейчас исполняет программу

Есть регистры общего назначения, в которые мы можем складывать данные, проводить с ними арифметические операции и т.п.

Первые 8 регистров в x86 имеют исторические названия, до прихода AMD с 64-битными процессорами

![](../common/Pasted%20image%2020250306161848.png)

Есть большой 64-битный регистр `rax`, к его нижней половине (младшей) можно обратиться как к регистру `eax` - 32 бита, к младшей половине `eax` можно обратиться как к регистру `ax` - 16 бит и т.д. Это сделано для обратной совместимости

Регистры `*sp` имеют специальное значение, пока их не трогаем

*Набор регистров процессора называется регистровый файл*

В современных процессорах эти регистры не физические, а виртуальные
### Первые инструкции
Инструкции выглядят следующим образом `мнемоника операнд, операнд`

#### mov
Копировать данные из одного места в другое
```asm
mov DST, SRC // копировать SRC в DST

mov ebx, eax // скопировать биты eax в ebx
			 // старое значение ebx теряется

mov ax, bx 
mav ah, bh
```

Когда работаем с 32-битными регистрами и меняем 32-битные регистры, то верхняя часть соответствующего 64-битного регистра обнуляется

```asm
mov eax, ebx
```
Поэтому такая инструкция не только копирует биты `ebx` в `eax`, но и обнуляет старшие 32 бита регистра `rbx`. Понять нельзя, надо запомнить/почувствовать

Можем положить в регистр непосредственно заданный операнд
```asm
mov rcx, 42 // положить rcx битовое представление числа 42

mov rdx, 0x80 // шестнадацатиричная запись опредан
mov eax, -1 // установить все биты eax в 1 (а старшние биты rax в 0)
```

### Арифметические инструкции
```asm
add DST, SRC // DST += SRC
sub DST, SRC // DST -= SRC
inc DST      // DST++
dec DST      // DST--
neg DST      // DST = -DST
not DST      // DST = ~DST
and DST, SRC // DST &= SRC
or  DST, SRC // DST |= SRC
xor DST, SRC // DST ^= SRC
```

### Библиотека simpleio
Предоставляет нам простые способы считывать и записывать числа

```asm
call write32 // напечатать на экране значение edi 
			 // как знаковое десятичное число
call write64 // вывести rdi
call readi32 // ввести с клавиатуры число и сохранить в eax
call readi64 // ввести с клавиатуры число и сохранить в rax
call finish  // завершить исполнение программы
```

Подпрограммы пользуются регистрами, поэтому не можем рассчитывать, что все регистры остаются целыми. Любой вызов подпрограммы сохраняет неизменными значения регистров `rbx, rsp, rbp, r12-r15`. Остальные регистры могу измениться произвольным образом

```asm
	.intel_syntax noprefix 
	.global main
main:
	call readi64 // считали первое число
	mov r12, rax // сохранили его в r12
	call readi64 // считали второе число
	add r12, rax // сложили первое и второе числа
	mov rdi, r12
	call writei64 // вывели результат
	call finish // завершили программу
```

- `.intel_syntax noprefix` - директива, переключаем ассемблер в режим синтаксиса Intel, используем noprefix чтобы синтаксис Intel таким, как его задумывал Intel 

Если бы не написали noprefix, то пришлось бы писать перед названиями регистра писать `%`

- `.global main` - этот кусок программы экспортирует символ main, сможет его найти только если обозначим его как global
- `main:` - метка, запомни по какому адресу в памяти ты сейчас записываешь инструкции и сохрани этот адрес в эту метку

*Число в регистре не получится интерпретировать как инструкцию. У процессора нет поддержки для этого*

Увидев инструкцию, ассемблер записывает ее машинную кодировку в выходной файл

Сохраним в файл с расширением `.S`
```shell
gcc -g sum.S simpleio_x86_64.S -o sum
./sum
```

Если не написать `call finish`, то процессор пойдет выполнять инструкции дальше, а за программой в памяти будет лежать мусор - процессор будет выполнять эти случайные данные

*gcc - GNU compiler collection*

Можем посмотреть на машинный код, который сгенерировался ассемблером. Для этого нужна программа `objdump`

```shell
objdump -d sum | less
```
- `-d` - дизассемблирование, прочитать машинный код из файла и показать нам его в мнемониках ассемблера. Машинный код в выходном файле интерпретирует как инструкции процессора и показывает нам, что значат байты в это файле
- `less` - с помощью этой программы удобнее читать, что напечатает нам objdump
- `-M intel` - для использования синтаксиса Intel, по умолчанию синтаксис AT&T

`next` в gdb - выполнить следующую строчку кода, не заходя в подпрограммы

`print $r12` - напечатали в gdb значение регистра r12

Будем постоянно возвращаться к ассемблеру - способ осознавать машинный код, то как работает машина

#### Инструкции сдвига
То, что не попадает в регистроприемник - выпадает и теряется (например, при сложении происходит переполнение - старший разряд выпадает и теряется, получаем все 0)

*Каждые 2 шестнадцатеричных разряда - это 1 байт*

```asm
mob ax, 0x1234
shr ax, 4 // ax == 0x0123 - сдвинули на 4 бита вправо
shl ax, 4 // ax == 0x1230
add ax, 7 // ax == 0x1237
ror ax, 4 // ax == 0x7123 // циклический сдвиг, rotate right
```

Это *логический сдвиг*, он дополняет результат всегда нулями

*Сдвиг вправо - деление на степень 2*

Так же бывает *арифметический сдвиг* - если у нас знаковое число, то нам хотелось бы, чтобы старший разряд сохранил свое значение

```asm
mov ax, 0xfff0 // ax == -16
sar ax, 4 // ax == 0xffff == -1 
sal ax, 5 // ax == 0xfff0 == -16
```

Инструкция арифметического сдвига дополняет результат слева не нулями, а знаковым битом

Арифметический сдвиг влево полностью совпадает с логическим сдвигом влево - он в любом случае дополняет младшие разряды нулями

Процессор у себя внутри преобразует эти инструкции в более простые микрооперации, но нас как программистов это не волнует. Нам важно, что процессор выполнил инструкцию так, как она специфицирована в документации

Можно сдвинуть на константу, значение регистра `CL`. На значение другого регистра сдвинуть не получится, поэтому если хотим сдвинуть на какое-то значение, то надо будет использовать регистр `CL` - это младший байт регистра `rcx`

## Директивы языка ассемблер
В ассемблерном файле есть инструкции и директивы. Мы уже видели директиву `.global`, которая говорит - этот символ важно видеть ОС

ОС, когда будет запускать нашу программу будет искать в ней символ `main`, если назовем метку как-то иначе, то ОС ее не найдет. Можно экспортировать несколько меток. Можем определять другие метки у себя в программе и экспортировать их в `.global`. Позволяет видеть символ из других файлов

Мы видели директиву `.intel_syntax`, которая включает режим синтаксиса Intel

Есть директива `.att_syntax` - переводит ассемблер в режим синтаксиса AT&T

Инструкция `nop - no operation` - когда ассемблер ее увидит, то запишет в программу ее кодировку, она кодируется байтом `0x90`. Она не делает ничего, исполняется и ничего не происходит

Есть директива `.byte` - написать в выходной файл произвольный байт, принимает после себя список байт, которые надо записать в выходной файл

Можем написать в выходной файл несколько байт с одинаковым значением подряд. Для этого нам нужна директива `.skip сколько, байт`

*С точки зрения компьютера нет никакой разницы между тем, что мы сами написали байт в выходной файл или этот байт появился потому что мы написали инструкцию*

Директива `.word` - записывает то, что мы ей даем как последовательности из двух байт

Директива `.int` - записывает последовательности из 4 байт

Директива `.quad` - записывает последовательности из 8 байт

Архитектура x86 - *Little Endian* - сначала записываем в память младший байт, а потом по возрастанию старшинства

Теперь можем резервировать место для переменных. Когда мы захотим сделать переменную, у которой мы хотим сделать какое-то изначально заданное значение
```asm
x:
	.int 0xabcdef // ef cd ab 00 
```

Метка `x` указывает на адрес в памяти байт, которые представляют собой целочисленное значение 42. Дополняет байты 0 до нужного размера

*Инструкция - мнемоника и операнды, которые призывают ассемблер записать в выходной файл байты машинного кода. Директива в общем случае призывает ассемблер сделать что-то другое*
